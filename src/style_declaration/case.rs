use std::collections::HashMap;

use crate::to_css_kebab_case;

lazy_static! {
    static ref CAMEL_TO_KEBAB: HashMap<String, String> = vec![
        "accentColor",
        "alignContent",
        "alignItems",
        "alignSelf",
        "alignmentBaseline",
        "all",
        "animation",
        "animationDelay",
        "animationDirection",
        "animationDuration",
        "animationFillMode",
        "animationIterationCount",
        "animationName",
        "animationPlayState",
        "animationTimingFunction",
        "appearance",
        "aspectRatio",
        "backfaceVisibility",
        "background",
        "backgroundAttachment",
        "backgroundBlendMode",
        "backgroundClip",
        "backgroundColor",
        "backgroundImage",
        "backgroundOrigin",
        "backgroundPosition",
        "backgroundPositionX",
        "backgroundPositionY",
        "backgroundRepeat",
        "backgroundSize",
        "baselineShift",
        "blockSize",
        "border",
        "borderBlock",
        "borderBlockColor",
        "borderBlockEnd",
        "borderBlockEndColor",
        "borderBlockEndStyle",
        "borderBlockEndWidth",
        "borderBlockStart",
        "borderBlockStartColor",
        "borderBlockStartStyle",
        "borderBlockStartWidth",
        "borderBlockStyle",
        "borderBlockWidth",
        "borderBottom",
        "borderBottomColor",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
        "borderBottomStyle",
        "borderBottomWidth",
        "borderCollapse",
        "borderColor",
        "borderEndEndRadius",
        "borderEndStartRadius",
        "borderImage",
        "borderImageOutset",
        "borderImageRepeat",
        "borderImageSlice",
        "borderImageSource",
        "borderImageWidth",
        "borderInline",
        "borderInlineColor",
        "borderInlineEnd",
        "borderInlineEndColor",
        "borderInlineEndStyle",
        "borderInlineEndWidth",
        "borderInlineStart",
        "borderInlineStartColor",
        "borderInlineStartStyle",
        "borderInlineStartWidth",
        "borderInlineStyle",
        "borderInlineWidth",
        "borderLeft",
        "borderLeftColor",
        "borderLeftStyle",
        "borderLeftWidth",
        "borderRadius",
        "borderRight",
        "borderRightColor",
        "borderRightStyle",
        "borderRightWidth",
        "borderSpacing",
        "borderStartEndRadius",
        "borderStartStartRadius",
        "borderStyle",
        "borderTop",
        "borderTopColor",
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderTopStyle",
        "borderTopWidth",
        "borderWidth",
        "bottom",
        "boxShadow",
        "boxSizing",
        "breakAfter",
        "breakBefore",
        "breakInside",
        "captionSide",
        "caretColor",
        "clear",
        "clip",
        "clipPath",
        "clipRule",
        "color",
        "colorInterpolation",
        "colorInterpolationFilters",
        "colorScheme",
        "columnCount",
        "columnFill",
        "columnGap",
        "columnRule",
        "columnRuleColor",
        "columnRuleStyle",
        "columnRuleWidth",
        "columnSpan",
        "columnWidth",
        "columns",
        "contain",
        "content",
        "counterIncrement",
        "counterReset",
        "counterSet",
        "cursor",
        "direction",
        "display",
        "dominantBaseline",
        "emptyCells",
        "fill",
        "fillOpacity",
        "fillRule",
        "filter",
        "flex",
        "flexBasis",
        "flexDirection",
        "flexFlow",
        "flexGrow",
        "flexShrink",
        "flexWrap",
        "float",
        "floodColor",
        "floodOpacity",
        "font",
        "fontFamily",
        "fontFeatureSettings",
        "fontKerning",
        "fontOpticalSizing",
        "fontSize",
        "fontSizeAdjust",
        "fontStretch",
        "fontStyle",
        "fontSynthesis",
        "fontVariant",
        "fontVariantAlternates",
        "fontVariantCaps",
        "fontVariantEastAsian",
        "fontVariantLigatures",
        "fontVariantNumeric",
        "fontVariantPosition",
        "fontVariationSettings",
        "fontWeight",
        "gap",
        "grid",
        "gridArea",
        "gridAutoColumns",
        "gridAutoFlow",
        "gridAutoRows",
        "gridColumn",
        "gridColumnEnd",
        "gridColumnGap",
        "gridColumnStart",
        "gridGap",
        "gridRow",
        "gridRowEnd",
        "gridRowGap",
        "gridRowStart",
        "gridTemplate",
        "gridTemplateAreas",
        "gridTemplateColumns",
        "gridTemplateRows",
        "height",
        "hyphens",
        "imageOrientation",
        "imageRendering",
        "inlineSize",
        "inset",
        "insetBlock",
        "insetBlockEnd",
        "insetBlockStart",
        "insetInline",
        "insetInlineEnd",
        "insetInlineStart",
        "isolation",
        "justifyContent",
        "justifyItems",
        "justifySelf",
        "left",
        "letterSpacing",
        "lightingColor",
        "lineBreak",
        "lineHeight",
        "listStyle",
        "listStyleImage",
        "listStylePosition",
        "listStyleType",
        "margin",
        "marginBlock",
        "marginBlockEnd",
        "marginBlockStart",
        "marginBottom",
        "marginInline",
        "marginInlineEnd",
        "marginInlineStart",
        "marginLeft",
        "marginRight",
        "marginTop",
        "marker",
        "markerEnd",
        "markerMid",
        "markerStart",
        "mask",
        "maskClip",
        "maskComposite",
        "maskImage",
        "maskMode",
        "maskOrigin",
        "maskPosition",
        "maskRepeat",
        "maskSize",
        "maskType",
        "maxBlockSize",
        "maxHeight",
        "maxInlineSize",
        "maxWidth",
        "minBlockSize",
        "minHeight",
        "minInlineSize",
        "minWidth",
        "mixBlendMode",
        "objectFit",
        "objectPosition",
        "offset",
        "offsetDistance",
        "offsetPath",
        "offsetRotate",
        "opacity",
        "order",
        "orphans",
        "outline",
        "outlineColor",
        "outlineOffset",
        "outlineStyle",
        "outlineWidth",
        "overflow",
        "overflowAnchor",
        "overflowWrap",
        "overflowX",
        "overflowY",
        "overscrollBehavior",
        "overscrollBehaviorBlock",
        "overscrollBehaviorInline",
        "overscrollBehaviorX",
        "overscrollBehaviorY",
        "padding",
        "paddingBlock",
        "paddingBlockEnd",
        "paddingBlockStart",
        "paddingBottom",
        "paddingInline",
        "paddingInlineEnd",
        "paddingInlineStart",
        "paddingLeft",
        "paddingRight",
        "paddingTop",
        "pageBreakAfter",
        "pageBreakBefore",
        "pageBreakInside",
        "paintOrder",
        "perspective",
        "perspectiveOrigin",
        "placeContent",
        "placeItems",
        "placeSelf",
        "pointerEvents",
        "position",
        "printColorAdjust",
        "quotes",
        "resize",
        "right",
        "rotate",
        "rowGap",
        "rubyPosition",
        "scale",
        "scrollBehavior",
        "scrollMargin",
        "scrollMarginBlock",
        "scrollMarginBlockEnd",
        "scrollMarginBlockStart",
        "scrollMarginBottom",
        "scrollMarginInline",
        "scrollMarginInlineEnd",
        "scrollMarginInlineStart",
        "scrollMarginLeft",
        "scrollMarginRight",
        "scrollMarginTop",
        "scrollPadding",
        "scrollPaddingBlock",
        "scrollPaddingBlockEnd",
        "scrollPaddingBlockStart",
        "scrollPaddingBottom",
        "scrollPaddingInline",
        "scrollPaddingInlineEnd",
        "scrollPaddingInlineStart",
        "scrollPaddingLeft",
        "scrollPaddingRight",
        "scrollPaddingTop",
        "scrollSnapAlign",
        "scrollSnapStop",
        "scrollSnapType",
        "scrollbarGutter",
        "shapeImageThreshold",
        "shapeMargin",
        "shapeOutside",
        "shapeRendering",
        "stopColor",
        "stopOpacity",
        "stroke",
        "strokeDasharray",
        "strokeDashoffset",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeMiterlimit",
        "strokeOpacity",
        "strokeWidth",
        "tabSize",
        "tableLayout",
        "textAlign",
        "textAlignLast",
        "textAnchor",
        "textCombineUpright",
        "textDecoration",
        "textDecorationColor",
        "textDecorationLine",
        "textDecorationSkipInk",
        "textDecorationStyle",
        "textDecorationThickness",
        "textEmphasis",
        "textEmphasisColor",
        "textEmphasisPosition",
        "textEmphasisStyle",
        "textIndent",
        "textOrientation",
        "textOverflow",
        "textRendering",
        "textShadow",
        "textTransform",
        "textUnderlineOffset",
        "textUnderlinePosition",
        "top",
        "touchAction",
        "transform",
        "transformBox",
        "transformOrigin",
        "transformStyle",
        "transition",
        "transitionDelay",
        "transitionDuration",
        "transitionProperty",
        "transitionTimingFunction",
        "translate",
        "unicodeBidi",
        "userSelect",
        "verticalAlign",
        "visibility",
        "webkitAlignContent",
        "webkitAlignItems",
        "webkitAlignSelf",
        "webkitAnimation",
        "webkitAnimationDelay",
        "webkitAnimationDirection",
        "webkitAnimationDuration",
        "webkitAnimationFillMode",
        "webkitAnimationIterationCount",
        "webkitAnimationName",
        "webkitAnimationPlayState",
        "webkitAnimationTimingFunction",
        "webkitAppearance",
        "webkitBackfaceVisibility",
        "webkitBackgroundClip",
        "webkitBackgroundOrigin",
        "webkitBackgroundSize",
        "webkitBorderBottomLeftRadius",
        "webkitBorderBottomRightRadius",
        "webkitBorderRadius",
        "webkitBorderTopLeftRadius",
        "webkitBorderTopRightRadius",
        "webkitBoxAlign",
        "webkitBoxFlex",
        "webkitBoxOrdinalGroup",
        "webkitBoxOrient",
        "webkitBoxPack",
        "webkitBoxShadow",
        "webkitBoxSizing",
        "webkitFilter",
        "webkitFlex",
        "webkitFlexBasis",
        "webkitFlexDirection",
        "webkitFlexFlow",
        "webkitFlexGrow",
        "webkitFlexShrink",
        "webkitFlexWrap",
        "webkitJustifyContent",
        "webkitLineClamp",
        "webkitMask",
        "webkitMaskBoxImage",
        "webkitMaskBoxImageOutset",
        "webkitMaskBoxImageRepeat",
        "webkitMaskBoxImageSlice",
        "webkitMaskBoxImageSource",
        "webkitMaskBoxImageWidth",
        "webkitMaskClip",
        "webkitMaskComposite",
        "webkitMaskImage",
        "webkitMaskOrigin",
        "webkitMaskPosition",
        "webkitMaskRepeat",
        "webkitMaskSize",
        "webkitOrder",
        "webkitPerspective",
        "webkitPerspectiveOrigin",
        "webkitTextFillColor",
        "webkitTextSizeAdjust",
        "webkitTextStroke",
        "webkitTextStrokeColor",
        "webkitTextStrokeWidth",
        "webkitTransform",
        "webkitTransformOrigin",
        "webkitTransformStyle",
        "webkitTransition",
        "webkitTransitionDelay",
        "webkitTransitionDuration",
        "webkitTransitionProperty",
        "webkitTransitionTimingFunction",
        "webkitUserSelect",
        "whiteSpace",
        "widows",
        "width",
        "willChange",
        "wordBreak",
        "wordSpacing",
        "wordWrap",
        "writingMode",
        "zIndex"
    ]
    .into_iter()
    .map(|camel| { (camel.to_string(), to_css_kebab_case(camel)) })
    .collect();
    static ref KEBAB_TO_CAMEL: HashMap<String, String> = CAMEL_TO_KEBAB
        .iter()
        .map(|(camel, kebab)| (kebab.clone(), camel.clone()))
        .collect();
}

pub fn to_camel(kebab_or_camel: &str) -> Option<String> {
    KEBAB_TO_CAMEL.get(kebab_or_camel).cloned().or_else(|| {
        CAMEL_TO_KEBAB
            .contains_key(kebab_or_camel)
            .then(|| kebab_or_camel.to_string())
    })
}

pub fn to_kebab(kebab_or_camel: &str) -> Option<String> {
    CAMEL_TO_KEBAB.get(kebab_or_camel).cloned().or_else(|| {
        KEBAB_TO_CAMEL
            .contains_key(kebab_or_camel)
            .then(|| kebab_or_camel.to_string())
    })
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_to_camel() {
        assert_eq!(
            to_camel("background-color"),
            Some("backgroundColor".to_string())
        );
        assert_eq!(
            to_camel("backgroundColor"),
            Some("backgroundColor".to_string())
        );
        assert_eq!(to_camel("not-a-css-property"), None);
    }

    #[test]
    fn test_to_kebab() {
        assert_eq!(
            to_kebab("background-color"),
            Some("background-color".to_string())
        );
        assert_eq!(
            to_kebab("backgroundColor"),
            Some("background-color".to_string())
        );
        assert_eq!(to_kebab("not-a-css-property"), None);
    }
}
